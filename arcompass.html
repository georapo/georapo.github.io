<!doctype html>
<html lang="fi">
<meta charset="utf-8"/>
<title>Digital AR Compass</title>
<style>
  body, html { margin:0; height:100%; overflow:hidden; background:#000; color:#fff; font-family:system-ui,Segoe UI,Roboto;}
  #camera { position:fixed; inset:0; }
  video#cam { width:100%; height:100%; object-fit:cover; transform:scaleX(-1); }

  #hud {
    position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,0.4); padding:10px 16px; border-radius:12px;
    text-align:center; z-index:20;
  }
  #arrow2d {
    width:80px; height:80px; display:block; margin:0 auto;
    transform-origin:center center;
    transition:transform 0.05s linear, opacity 0.2s ease;
  }
  #info { margin-top:8px; font-size:14px; }

  canvas#three { position:fixed; inset:0; pointer-events:none; z-index:10; }
</style>
<body>
  <div id="camera">
    <video id="cam" autoplay playsinline muted></video>
  </div>
  <canvas id="three"></canvas> <!-- THREEJS PART -->
  <div id="hud">
    <img id="arrow2d" src="data:image/svg+xml;utf8,
      <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'>
        <polygon points='50,5 95,95 50,75 5,95' fill='white'/>
      </svg>"/>
    <div id="info">
      <div id="dist">Etäisyys: — m</div>
      <div id="bearing">Kohteen suunta: —°</div>
      <div id="azimuth">Puhelimen katselusuunta: —°</div>
    </div>
  </div>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.162.0/build/three.module.js';

// --- CONFIG: laita tähän kohteen koordinaatit (WGS84) ---
const target = { lat: 60.192059, lon: 24.945831 }; // esimerkki: Helsinki

// --- HELPERS: matematiikka ---
const DEG2RAD = Math.PI/180;
const RAD2DEG = 180/Math.PI;
function toRad(d){return d*DEG2RAD;}
function toDeg(r){return r*RAD2DEG;}

// Haversine distance (metreinä)
function haversineDistance(lat1, lon1, lat2, lon2){
  const R = 6371000; // m
  const dLat = toRad(lat2-lat1);
  const dLon = toRad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  const c = 2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R*c;
}

// Initial bearing from point A to B (degrees clockwise from north)
function initialBearing(lat1, lon1, lat2, lon2){
  const φ1 = toRad(lat1), φ2 = toRad(lat2);
  const λ1 = toRad(lon1), λ2 = toRad(lon2);
  const y = Math.sin(λ2-λ1)*Math.cos(φ2);
  const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
  let θ = Math.atan2(y,x);
  θ = (toDeg(θ) + 360) % 360; // bearing from north? currently from east==0; adjust below
  // Above θ is clockwise from east; convert to clockwise from north:
  // clockwise_from_north = (90 - θ_from_math) mod 360  -> simpler compute using atan2(east,north)
  // But because we computed using sin(lon2-lon1)*cosφ2 as y and x as above,
  // many references give: bearing = (atan2(y, x) * 180/PI + 360) % 360
  // That result is bearing clockwise from north. So return θ.
  return θ;
}

// NORMALIZE 0..360
function norm360(a){ return ((a % 360) + 360) % 360; }

// --- Quaternion helpers ---
function quatConjugate(q){ return {w:q.w, x:-q.x, y:-q.y, z:-q.z}; }
function quatMultiply(a,b){
  return {
    w: a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
    x: a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
    y: a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
    z: a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w
  };
}
function rotateVectorByQuat(v, q){
  // v: {x,y,z}, q: {w,x,y,z}
  const qv = {w:0, x:v.x, y:v.y, z:v.z};
  const qc = quatConjugate(q);
  const tmp = quatMultiply(q, qv);
  const res = quatMultiply(tmp, qc);
  return { x: res.x, y: res.y, z: res.z };
}

// Convert DOMScreen orientation angle (degrees) to a quaternion that rotates device coordinates to account for screen rotation
function screenRotationQuat(angleDeg){
  // rotation about Z axis by -angleDeg (because screen rotation rotates coordinate frame)
  const a = toRad(-angleDeg/2);
  return { w: Math.cos(a), x:0, y:0, z: Math.sin(a) };
}

// Multiply two quaternions easily
// (provided above as quatMultiply)

// --- DEVICE ORIENTATION: prefer AbsoluteOrientationSensor ---
let orientationQuat = {w:1,x:0,y:0,z:0}; // device -> world quaternion (best-effort)
let haveOrientation = false;

async function startOrientation(){
  if ('AbsoluteOrientationSensor' in window){
    try {
      const sensor = new AbsoluteOrientationSensor({frequency:60, referenceFrame:'device'});
      sensor.addEventListener('reading', () => {
        const q = sensor.quaternion; // [x,y,z,w]
        orientationQuat = {w: q[3], x:q[0], y:q[1], z:q[2]};
        haveOrientation = true;
      });
      sensor.addEventListener('error', ev => {
        console.warn('Orientation sensor error', ev);
      });
      sensor.start();
      return;
    } catch(e){
      console.warn('AbsoluteOrientationSensor failed:', e);
    }
  }

  // Fallback: DeviceOrientationEvent -> build quaternion from alpha/beta/gamma
  function handleDevOrient(e){
    // On iOS, must first call DeviceOrientationEvent.requestPermission() from user gesture.
    if (e.absolute === false && e.alpha === null) return;
    const alpha = e.alpha ? toRad(e.alpha) : 0; // Z
    const beta  = e.beta  ? toRad(e.beta)  : 0; // X
    const gamma = e.gamma ? toRad(e.gamma) : 0; // Y

    // Convert Z-X'-Y'' (alpha, beta, gamma) intrinsic Tait-Bryan -> quaternion
    // Using standard conversion from deviceorientation spec
    const c1 = Math.cos(alpha/2), s1 = Math.sin(alpha/2);
    const c2 = Math.cos(beta/2),  s2 = Math.sin(beta/2);
    const c3 = Math.cos(gamma/2), s3 = Math.sin(gamma/2);

    // q = qz * qx * qy  (order matters)
    const w = c1*c2*c3 - s1*s2*s3;
    const x = c1*s2*c3 + s1*c2*s3;
    const y = c1*c2*s3 + s1*s2*c3;
    const z = s1*c2*c3 - c1*s2*s3;
    orientationQuat = {w:x? (w):w, x:x, y:y, z:z}; // use computed values
    haveOrientation = true;
  }

  if ('DeviceOrientationEvent' in window){
    // iOS needs permission
    if (typeof DeviceOrientationEvent.requestPermission === 'function'){
      // don't call automatically; request when user interacts - try to request immediately
      DeviceOrientationEvent.requestPermission().then(perm => {
        if (perm === 'granted') window.addEventListener('deviceorientation', handleDevOrient);
      }).catch(err => {
        console.warn('DeviceOrientation permission request failed', err);
      });
    } else {
      window.addEventListener('deviceorientation', handleDevOrient);
    }
  }
}

// --- CAMERA START (getUserMedia) ---
async function startCamera(){
  try {
    const vid = document.getElementById('cam');
    const stream = await navigator.mediaDevices.getUserMedia({video:{ facingMode:'environment' }, audio:false});
    vid.srcObject = stream;
  } catch(e){ console.warn('Camera error', e); }
}

// --- MAIN: sijainti & päivitykset ---
let currentPos = null;
function startGeolocation(){
  if (!('geolocation' in navigator)) { alert('Geolocation ei saatavilla'); return; }
  navigator.geolocation.watchPosition(pos => {
    currentPos = { lat: pos.coords.latitude, lon: pos.coords.longitude };
  }, err => {
    console.warn('geolocation error', err);
  }, { enableHighAccuracy:true, maximumAge:1000, timeout:5000 });
}

function getScreenAngle(){
  // use Screen Orientation API if available, fallback to window.orientation
  if (screen.orientation && typeof screen.orientation.angle === 'number') return screen.orientation.angle;
  if (typeof window.orientation === 'number') return window.orientation;
  return 0;
}

/* --- THREEJS PART: setup 3D arrow --- */
const threeCanvas = document.getElementById('three');
const renderer = new THREE.WebGLRenderer({canvas:threeCanvas, alpha:true, antialias:true});
const scene = new THREE.Scene();
const camera3d = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 100);
camera3d.position.z = 2;

// 3D-nuoli (sylinteri + kartio)
const shaft = new THREE.Mesh(
  new THREE.CylinderGeometry(0.02,0.02,0.8,16),
  new THREE.MeshStandardMaterial({color:0xffffff, metalness:0.3, roughness:0.4})
);
const head = new THREE.Mesh(
  new THREE.ConeGeometry(0.06,0.2,20),
  new THREE.MeshStandardMaterial({color:0xff3333, metalness:0.1, roughness:0.3})
);
head.position.y = 0.5;
shaft.add(head);
scene.add(shaft);

const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(0,1,1);
scene.add(light);

// keep arrow visible flag
let show3D = false;
let pitchDeg = 0;

window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera3d.aspect = window.innerWidth/window.innerHeight;
  camera3d.updateProjectionMatrix();
});
renderer.setSize(window.innerWidth, window.innerHeight);


// override updateHUD to add 3D arrow logic
const arrow2d = document.getElementById('arrow2d');
function updateHUD(){
  const distEl = document.getElementById('dist');
  const bearingEl = document.getElementById('bearing');
  const azEl = document.getElementById('azimuth');

  if (!currentPos || !haveOrientation){
    requestAnimationFrame(updateHUD);
    return;
  }

  const dist = haversineDistance(currentPos.lat, currentPos.lon, target.lat, target.lon);
  const geoBearing = initialBearing(currentPos.lat, currentPos.lon, target.lat, target.lon);
  distEl.textContent = `Etäisyys: ${dist<1000 ? Math.round(dist)+' m' : (dist/1000).toFixed(2)+' km'}`;
  bearingEl.textContent = `Kohteen suunta: ${geoBearing.toFixed(1)}°`;

  const deviceForward = {x:0,y:0,z:-1};
  const screenQ = screenRotationQuat(getScreenAngle());
  const v_afterScreen = rotateVectorByQuat(deviceForward, screenQ);
  const worldForward = rotateVectorByQuat(v_afterScreen, orientationQuat);

  const fx = worldForward.x;
  const fy = worldForward.y;
  const fz = worldForward.z;
  const horizLen = Math.hypot(fx, fy);
  let azimuthDeg = null;
  if (horizLen < 1e-6){
    azimuthDeg = null;
    azEl.textContent = `Puhelimen katselusuunta: —°`;
  } else {
    const headingRad = Math.atan2(fx, fy);
    azimuthDeg = norm360(toDeg(headingRad));
    azEl.textContent = `Puhelimen katselusuunta: ${azimuthDeg.toFixed(1)}°`;
  }

  // laske kallistuskulma (pitch) worldForward.z:sta
  pitchDeg = toDeg(Math.asin(-worldForward.z)); // 0=horisontti, +90=ylös
  show3D = pitchDeg > 45; // jos laite pystyssä, käytetään 3D-nuolta

  // 2D-nuolen päivitys
  let relative = 0;
  if (azimuthDeg != null){
    let diff = geoBearing - azimuthDeg;
    diff = ((diff + 540) % 360) - 180;
    relative = diff;
  }
  arrow2d.style.transform = `rotate(${relative}deg)`;
  arrow2d.style.opacity = show3D ? 0 : 1; // fade out 2D when 3D visible

  // 3D-nuolen päivitys
  if (show3D){
    // Pyöritetään 3D-nuolta osoittamaan oikeaan suuntaan (bearing)
    const yaw = toRad(-relative); // negatiivinen koska CSS-kääntö ja 3D-akselit eri
    shaft.rotation.set(0, yaw, 0);
  }

  // renderöidään scene jos 3D-tila näkyvissä
  renderer.setClearColor(0x000000, show3D?0:0); // täysin läpinäkyvä
  if (show3D) renderer.render(scene, camera3d);

  requestAnimationFrame(updateHUD);
}


// start everything
(async function init(){
  await startCamera();
  startGeolocation();
  await startOrientation();
  updateHUD();
})();
</script>
</body>
</html>
